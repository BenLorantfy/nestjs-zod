import { UnknownSchema } from './types'
import { toSwagger } from './openapi/to-swagger'
import type * as z3 from 'zod/v3';
import type * as z4 from "zod/v4/core";

export interface ZodDto<
  TSchema extends UnknownSchema
> {
  new (): ReturnType<TSchema['parse']>
  isZodDto: true
  schema: TSchema
  create(input: unknown): ReturnType<TSchema['parse']>
  _OPENAPI_METADATA_FACTORY(): unknown
}

export function createZodDto<
  TSchema extends UnknownSchema|z3.ZodTypeAny|(z4.$ZodType & { parse: (input: unknown) => unknown })
>(schema: TSchema) {
  class AugmentedZodDto {
    public static isZodDto = true
    public static schema = schema

    public static create(input: unknown) {
      return this.schema.parse(input)
    }

    public static _OPENAPI_METADATA_FACTORY() {
      const swaggerSchema = toSwagger(this.schema);
      return normalizeOpenAPISchemaForNest(swaggerSchema).properties;
    }
  }

  return AugmentedZodDto as unknown as ZodDto<TSchema>
}

/**
 * Transforms a standard OpenAPI-compatible JSON Schema (as generated by Zod)
 * into the simplified format expected by NestJS's `_OPENAPI_METADATA_FACTORY`.
 *
 * Nest expects an object like:
 * ```
 * {
 *   a: { type: 'string', required: true },
 * }
 * ```
 * Instead of a proper JSONSchema like this:
 * ```
 * {
 *   type: 'object',
 *   properties: {
 *     a: { type: 'string' },
 *   },
 *   required: ['a'],
 * }
 * ```
 *
 * This function performs the following transformations:
 * - Adds `selfRequired: true` or
 *   `required: true` where needed, based of  the top-level `required` array.
 * - Ensures each property has a `type`, even when Zod outputs `anyOf`
 *   constructs (e.g., from `.nullable()` or unions).
 *
 * The result is compatible with NestJS Swagger's `_OPENAPI_METADATA_FACTORY`
 * expectation for class metadata.
 */
export function normalizeOpenAPISchemaForNest(schema: {
  properties?: Record<string, {}>;
  required?: string[];
}) {
  if (!schema.properties) return schema;
  return {
    ...schema,
    properties: Object.keys(schema.properties).reduce((acc, key) => {
      const subSchema = schema.properties![key]

      // the expectation is that we always define a type
      if (!('type' in subSchema)) {
        (subSchema as { type?: string }).type = 'object';
      }

      if ('type' in subSchema && subSchema.type === 'object') {
        acc[key] = {
          ...subSchema,
          // selfRequired seems to be needed to tell nest/swagger that the property is required, when the property is an object.
          // I think this is an undocumented feature of nest/swagger.  I don't think it's part of the OpenAPI schema.
          // @see https://github.com/nestjs/swagger/pull/3347/files#diff-bd4375f8c339aca69690041a14da31752c1d4707eba6eb1129e5922454d3c7d4R272
          selfRequired: !!schema.required?.includes(key),
        }
      } else {
        acc[key] = {
          ...subSchema,
          // selfRequired doesn't seem to work when the property is not an
          // object, but `required` does. Using required like this is also not
          // part of the OpenAPI schema, but nest/swagger seems to support it
          required: !!schema.required?.includes(key),
        }
      }
      return acc
    }, {} as Record<string, unknown>)
  }
}

export function isZodDto(metatype: unknown): metatype is ZodDto<UnknownSchema> {
  return Boolean(metatype && (typeof metatype === 'object' || typeof metatype === 'function') && 'isZodDto' in metatype && metatype.isZodDto);
}
